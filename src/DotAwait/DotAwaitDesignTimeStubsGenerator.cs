using DotAwait.WellKnown;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;

namespace DotAwait;

[Generator(LanguageNames.CSharp)]
public sealed class DotAwaitDesignTimeStubsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName: WellKnownTypeFullNames.DotAwaitAttribute,
            predicate: static (node, _) =>
                node is MethodDeclarationSyntax m
                && m.Body is null
                && m.ExpressionBody is null
                && m.SemicolonToken.IsKind(SyntaxKind.SemicolonToken)
                && m.Modifiers.Any(SyntaxKind.PartialKeyword),
            transform: static (ctx, ct) =>
            {
                var methodSyntax = (MethodDeclarationSyntax)ctx.TargetNode;
                var methodSymbol = (IMethodSymbol)ctx.TargetSymbol;
                return new Candidate(methodSyntax, methodSymbol);
            });

        var methods = candidates
            .Where(static c => c.Symbol.IsExtensionMethod && c.Symbol.Parameters.Length == 1)
            .Select(static (c, _) => c);

        context.RegisterSourceOutput(
            methods.Collect(),
            static (spc, items) => Emit(spc, items));
    }

    private static void Emit(SourceProductionContext context, ImmutableArray<Candidate> items)
    {
        if (items.Length == 0)
            return;

        var byType = new Dictionary<INamedTypeSymbol, List<Candidate>>(SymbolEqualityComparer.Default);

        foreach (var c in items)
        {
            var def = c.Symbol.PartialDefinitionPart ?? c.Symbol;

            if (def.PartialImplementationPart is not null)
                continue;

            if (!byType.TryGetValue(def.ContainingType, out var list))
            {
                list = new List<Candidate>();
                byType.Add(def.ContainingType, list);
            }

            list.Add(c);
        }

        foreach (var kv in byType)
        {
            var type = kv.Key;
            var list = kv.Value;

            var hint = "DotAwait_DesignTime_" + SafeHint(type) + ".g.cs";
            var src = Generate(type, list);
            context.AddSource(hint, src);
        }
    }

    private static string Generate(INamedTypeSymbol type, List<Candidate> methods)
    {
        var ns = type.ContainingNamespace?.IsGlobalNamespace == false
            ? type.ContainingNamespace.ToDisplayString()
            : null;

        var typeChain = new Stack<INamedTypeSymbol>();
        for (var t = type; t is not null; t = t.ContainingType)
            typeChain.Push(t);

        var cu = SyntaxFactory.CompilationUnit();

        MemberDeclarationSyntax? innerMost = null;

        while (typeChain.Count != 0)
        {
            var t = typeChain.Pop();

            var decl = CreatePartialTypeShell(t);

            if (innerMost is not null)
                decl = decl.WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(innerMost));

            innerMost = decl;
        }

        var methodMembers = methods
            .Select(m => (MemberDeclarationSyntax)CreateImplementation(m.Syntax))
            .ToList();

        innerMost = ((TypeDeclarationSyntax)innerMost!).WithMembers(SyntaxFactory.List(methodMembers));

        if (ns is not null)
            cu = cu.AddMembers(SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(ns)).AddMembers(innerMost));
        else
            cu = cu.AddMembers(innerMost);

        var text = cu
            .NormalizeWhitespace(eol: "\n")
            .ToFullString();

        return
            "// <auto-generated/>\n" +
            "#nullable enable\n" +
            "#if DOTAWAIT_DESIGN_TIME\n" +
            text + "\n" +
            "#endif\n";
    }

    private static TypeDeclarationSyntax CreatePartialTypeShell(INamedTypeSymbol t)
    {
        var kind = t.TypeKind switch
        {
            TypeKind.Class => SyntaxKind.ClassDeclaration,
            TypeKind.Struct => SyntaxKind.StructDeclaration,
            TypeKind.Interface => SyntaxKind.InterfaceDeclaration,
            _ => SyntaxKind.ClassDeclaration
        };

        var name = SyntaxFactory.Identifier(t.Name);

        TypeDeclarationSyntax decl = kind switch
        {
            SyntaxKind.ClassDeclaration => SyntaxFactory.ClassDeclaration(name),
            SyntaxKind.StructDeclaration => SyntaxFactory.StructDeclaration(name),
            SyntaxKind.InterfaceDeclaration => SyntaxFactory.InterfaceDeclaration(name),
            _ => SyntaxFactory.ClassDeclaration(name)
        };

        var modifiers = new List<SyntaxToken>();

        modifiers.Add(t.DeclaredAccessibility switch
        {
            Accessibility.Public => SyntaxFactory.Token(SyntaxKind.PublicKeyword),
            Accessibility.Internal => SyntaxFactory.Token(SyntaxKind.InternalKeyword),
            Accessibility.Private => SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
            Accessibility.Protected => SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
            Accessibility.ProtectedOrInternal => SyntaxFactory.Token(SyntaxKind.ProtectedKeyword),
            Accessibility.ProtectedAndInternal => SyntaxFactory.Token(SyntaxKind.PrivateKeyword),
            _ => default
        });

        if (t.DeclaredAccessibility is Accessibility.ProtectedOrInternal)
            modifiers.Add(SyntaxFactory.Token(SyntaxKind.InternalKeyword));

        if (t.DeclaredAccessibility is Accessibility.ProtectedAndInternal)
            modifiers.Add(SyntaxFactory.Token(SyntaxKind.ProtectedKeyword));

        if (t.IsStatic)
            modifiers.Add(SyntaxFactory.Token(SyntaxKind.StaticKeyword));

        modifiers.Add(SyntaxFactory.Token(SyntaxKind.PartialKeyword));

        decl = decl.WithModifiers(SyntaxFactory.TokenList(modifiers.Where(m => !m.IsKind(SyntaxKind.None))));

        if (t.TypeParameters.Length != 0)
        {
            var tp = t.TypeParameters.Select(p => SyntaxFactory.TypeParameter(p.Name));
            decl = decl.WithTypeParameterList(SyntaxFactory.TypeParameterList(SyntaxFactory.SeparatedList(tp)));

            var clauses = BuildTypeConstraintClauses(t.TypeParameters);
            if (clauses.Count != 0)
                decl = decl.WithConstraintClauses(clauses);
        }

        return decl.WithMembers(default);
    }

    private static SyntaxList<TypeParameterConstraintClauseSyntax> BuildTypeConstraintClauses(ImmutableArray<ITypeParameterSymbol> tps)
    {
        var list = new List<TypeParameterConstraintClauseSyntax>();

        foreach (var tp in tps)
        {
            var constraints = new List<TypeParameterConstraintSyntax>();

            if (tp.HasNotNullConstraint)
                constraints.Add(SyntaxFactory.TypeConstraint(SyntaxFactory.ParseTypeName("notnull")));

            if (tp.HasUnmanagedTypeConstraint)
                constraints.Add(SyntaxFactory.TypeConstraint(SyntaxFactory.ParseTypeName("unmanaged")));
            else if (tp.HasValueTypeConstraint)
                constraints.Add(SyntaxFactory.ClassOrStructConstraint(SyntaxKind.StructConstraint));
            else if (tp.HasReferenceTypeConstraint)
                constraints.Add(SyntaxFactory.ClassOrStructConstraint(SyntaxKind.ClassConstraint));

            foreach (var ct in tp.ConstraintTypes)
                constraints.Add(SyntaxFactory.TypeConstraint(SyntaxFactory.ParseTypeName(ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))));

            if (tp.HasConstructorConstraint)
                constraints.Add(SyntaxFactory.ConstructorConstraint());

            if (constraints.Count == 0)
                continue;

            list.Add(
                SyntaxFactory.TypeParameterConstraintClause(
                    SyntaxFactory.IdentifierName(tp.Name),
                    SyntaxFactory.SeparatedList(constraints)));
        }

        return SyntaxFactory.List(list);
    }

    private static MethodDeclarationSyntax CreateImplementation(MethodDeclarationSyntax decl)
    {
        var body = SyntaxFactory.Block(
            SyntaxFactory.ThrowStatement(
                SyntaxFactory
                    .ObjectCreationExpression(
                        SyntaxFactory.ParseTypeName("global::System.Diagnostics.UnreachableException"))
                    .WithArgumentList(
                        SyntaxFactory.ArgumentList(
                            SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.Argument(
                                    SyntaxFactory.LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        SyntaxFactory.Literal("[DotAwait] This code should never be reached."))))))));

        return decl
            .WithAttributeLists(default)
            .WithSemicolonToken(default)
            .WithExpressionBody(null)
            .WithBody(body)
            .WithoutLeadingTrivia()
            .WithoutTrailingTrivia();
    }

    private static string SafeHint(INamedTypeSymbol t)
    {
        var s = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        return t.Name + "_" + unchecked((uint)s.GetHashCode()).ToString("x8");
    }

    private readonly record struct Candidate(MethodDeclarationSyntax Syntax, IMethodSymbol Symbol);
}
